from flask import Flask, jsonify, request, Response, stream_with_context
from flask_cors import CORS
from werkzeug.exceptions import HTTPException
import json
import time
import random
import threading

app = Flask(__name__)
# Enable CORS for all domains, crucial for front-end development
CORS(app)

# This is where your actual backend logic will go.
# For this example, we'll use dummy data to simulate the results.

def run_security_scan():
    """Simulates a security scan and returns a list of detected threats."""
    possible_threats = [
        {
            "id": 1,
            "name": "Suspicious Registry Entry",
            "type": "Registry Persistence",
            "severity": "High",
            "icon": "üìù",
            "location": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Run",
            "description": "Unauthorized startup entry detected",
            "details": "Detected suspicious registry modification in Windows startup location. This could indicate malware persistence mechanism.",
            "timestamp": time.strftime("%Y-%m-%d %H:%M:%S"),
            "selected": False
        },
        {
            "id": 2,
            "name": "Unknown Service Installation",
            "type": "Service Persistence",
            "severity": "Medium",
            "icon": "‚öôÔ∏è",
            "location": "Services.msc",
            "description": "New service with suspicious behavior patterns",
            "details": "A new Windows service was installed with unusual characteristics and network communication patterns.",
            "timestamp": time.strftime("%Y-%m-%d %H:%M:%S"),
            "selected": False
        },
        {
            "id": 3,
            "name": "Scheduled Task Anomaly",
            "type": "Task Scheduler",
            "severity": "High",
            "icon": "‚è∞",
            "location": "Task Scheduler Library",
            "description": "Malicious scheduled task for persistence",
            "details": "Suspicious scheduled task detected that executes PowerShell commands at system startup.",
            "timestamp": time.strftime("%Y-%m-%d %H:%M:%S"),
            "selected": False
        },
        {
            "id": 4,
            "name": "Suspicious PowerShell Activity",
            "type": "Command Execution",
            "severity": "Critical",
            "icon": "‚ö†Ô∏è",
            "location": "PowerShell.exe",
            "description": "Obfuscated PowerShell commands detected",
            "details": "Detected obfuscated PowerShell commands attempting to download external payloads from suspicious domains.",
            "timestamp": time.strftime("%Y-%m-%d %H:%M:%S"),
            "selected": False
        },
        {
            "id": 5,
            "name": "Unauthorized Network Connection",
            "type": "Network Activity",
            "severity": "High",
            "icon": "üåê",
            "location": "Network Interface",
            "description": "Connection to known malicious IP address",
            "details": "Process attempting to connect to known malicious IP address 192.168.1.100 on suspicious port.",
            "timestamp": time.strftime("%Y-%m-%d %H:%M:%S"),
            "selected": False
        },
        {
            "id": 6,
            "name": "Process Injection Detected",
            "type": "Code Injection",
            "severity": "Critical",
            "icon": "üíâ",
            "location": "System Process",
            "description": "Code injection attempt in legitimate process",
            "details": "Code injection attempt detected in legitimate system process, indicating advanced malware techniques.",
            "timestamp": time.strftime("%Y-%m-%d %H:%M:%S"),
            "selected": False
        }
    ]
    # Randomly select a few threats to simulate a scan result
    num_threats = random.randint(0, len(possible_threats))
    return random.sample(possible_threats, num_threats)

def _generate_random_threat(threat_id: int):
    """Helper to generate a single random threat payload with a given ID."""
    base = random.choice(run_security_scan() or [
        {
            "id": threat_id,
            "name": "Heuristic Suspicious Activity",
            "type": "Heuristic",
            "severity": random.choice(["Medium", "High", "Critical"]),
            "icon": "‚ö†Ô∏è",
            "location": "Runtime",
            "description": "Behavior deviates from baseline",
            "details": "Generated by heuristic engine.",
            "timestamp": time.strftime("%Y-%m-%d %H:%M:%S"),
            "selected": False,
        }
    ])
    # Ensure ID is unique and timestamp fresh
    base["id"] = threat_id
    base["timestamp"] = time.strftime("%Y-%m-%d %H:%M:%S")
    return base

@app.route('/healthz', methods=['GET'])
def healthz():
    """Simple health check endpoint."""
    return jsonify({"status": "ok"})

def mitigate_threats_on_backend(threat_ids):
    """Simulates mitigating threats on the backend."""
    # In a real application, you would implement the logic to remove
    # registry keys, stop services, delete files, etc.
    print(f"Mitigating threats with IDs: {threat_ids}")
    return {"status": "success", "message": f"Successfully mitigated {len(threat_ids)} threats."}

@app.route('/api/scan', methods=['POST'])
def scan_endpoint():
    try:
        # Simulate a delay for the scan process
        time.sleep(1)
        threats = run_security_scan()
        return jsonify(threats)
    except Exception as e:
        return jsonify({"status": "error", "message": str(e)}), 500

@app.route('/api/mitigate', methods=['POST'])
def mitigate_endpoint():
    try:
        data = request.get_json()
        if data is None:
            return jsonify({"status": "error", "message": "Invalid JSON body."}), 400
        threat_ids = data.get('threat_ids', [])
        if not threat_ids:
            return jsonify({"status": "error", "message": "No threat IDs provided."}), 400
        
        result = mitigate_threats_on_backend(threat_ids)
        return jsonify(result)
    except Exception as e:
        return jsonify({"status": "error", "message": str(e)}), 500

@app.route('/api/stream', methods=['GET'])
def stream_endpoint():
    """Server-Sent Events endpoint streaming real-time threat detections.

    Emits a JSON payload per event and periodic keepalive pings.
    """
    def event_stream():
        # Initial recommended retry; clients use this if they disconnect
        yield "retry: 3000\n\n"
        next_id = 1000
        try:
            last_ping = time.time()
            while True:
                # Emit a new threat randomly
                if random.random() < 0.6:  # ~60% chance to emit an event each cycle
                    threat = _generate_random_threat(next_id)
                    next_id += 1
                    payload = json.dumps(threat)
                    yield f"id: {threat['id']}\n"
                    yield "event: threat\n"
                    yield f"data: {payload}\n\n"

                # Periodic keepalive ping every 10 seconds
                now = time.time()
                if now - last_ping >= 10:
                    last_ping = now
                    yield "event: ping\n"
                    yield "data: keepalive\n\n"

                # Sleep a short interval to simulate near-real-time stream
                time.sleep(1)
        except GeneratorExit:
            # Client disconnected; stop streaming gracefully
            return
        except Exception as e:
            # Emit an SSE error event before closing
            err = json.dumps({"status": "error", "message": str(e)})
            yield "event: error\n"
            yield f"data: {err}\n\n"

    # Wrap generator with Flask context and return proper SSE headers
    response = Response(stream_with_context(event_stream()), mimetype='text/event-stream')
    # Extra headers helpful for proxies/CORS
    response.headers['Cache-Control'] = 'no-cache'
    response.headers['X-Accel-Buffering'] = 'no'  # disable buffering in some proxies
    response.headers['Access-Control-Allow-Origin'] = '*'
    return response


# ---------------- Global error handlers ----------------
@app.errorhandler(HTTPException)
def handle_http_exception(exc: HTTPException):
    response = {
        "status": "error",
        "message": exc.description,
        "code": exc.code,
    }
    return jsonify(response), exc.code


@app.errorhandler(Exception)
def handle_unexpected_exception(exc: Exception):
    response = {
        "status": "error",
        "message": str(exc),
        "code": 500,
    }
    return jsonify(response), 500

if __name__ == '__main__':
    # Bind to all interfaces for easier local testing; disable reloader for stable SSE
    app.run(host='0.0.0.0', port=5000, debug=True, use_reloader=False, threaded=True)
